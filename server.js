 //PORT variable configured by heroku
 var PORT = process.env.PORT || 3000;
 var moment = require ('moment');

//create new express app
var express = require ('express');

//create express app
var app = express();

//tell node to start a new server then use app as boilerplate 
var http = require ('http').Server(app);

//bring in http server with socket.io library
var io = require('socket.io')(http);

//use express static to expose folder
//express static takes file path as only argument 
app.use(express.static(__dirname + '/public'));


/*
1. empty object that'll have a set key/value pairs
2. the key is a unique socket ID (auto-generated by socket io)
3. the value is whatever the client joined in with (eg, name: and room: info chosen)
4. so, clientInfo = {'some unique socket id':{name:'some name', room:'some room'}}*/
var clientInfo = {};

function sendCurrentUsers(socket) {
	var info = clientInfo[socket.id];
	var users = [];

		//prevent searching clientInfo object for rooms that don't exist
		if (typeof info === 'undefined'){
			return;
		}	

		//Object.keys takes an object and returns all atributes on that object	
		Object.keys(clientInfo).forEach(function (socketId){
			var userInfo = clientInfo[socketId];

			if(info.room === userInfo.room){
				users.push(userInfo.name);
			}
		});

		socket.emit('message', {
			name: 'System',
			text: 'Current users: ' + users.join(', '),
			timespamp: moment().valueOf()
		});
}

//on is to listen to event, first argument is name of the event
//access individual socket
io.on('connection', function(socket){
	console.log('User connected via socket.io');


	//socket io comes with its own disconnect fxn
	socket.on('disconnect', function(){
		//check if user is part of chat room
		//
		if(typeof clientInfo[socket.id] !== 'undefined'){
			//var userData = clientInfo[socket.id];
			socket.leave(clientInfo[socket.id].room);
			io.to(clientInfo[socket.id].room).emit('message', {
				name: 'System',
				text: clientInfo[socket.id].name + ' has left the conversation',
				timestamp: moment().valueOf()
			});
			delete clientInfo[socket.id];
		}

	});

	socket.on('joinRoom', function (joinRoom){
		//associate unique socket id and name, room info passed in on joinRoom object
		clientInfo[socket.id] = joinRoom;
		//tells socket io library to add socket to a specific room
		socket.join(joinRoom.room);
		socket.broadcast.to(joinRoom.room).emit('message', {
			name: 'System',
			text: joinRoom.name + ' has joined!',
			timestamp: moment().valueOf()
		});

	});

	socket.on('message', function(message){
		console.log('message recieved: '+message.text);
			
		//if user types in command run sendCurrentUsers fxn
		if(message.text === '@currentUsers'){
			sendCurrentUsers(socket);
		} 
		else {
			//sends received message to everyone but the sender (current socket)
		//socket.broadcast.emit('message', message);
		message.timestamp = moment().valueOf();	
		//io.emit to emit message to all sockets in the same room
		io.to(clientInfo[socket.id].room).emit('message', message);
		}

	});

	//socket object, event method. event method takes two arguments
	//1st event name, 2nd data to send
	socket.emit('message', {
		name: 'System',
		text: 'Welcome to the chat app',
		//javascript timestamp using valueOf(). returns number, not string
		timestamp: moment().valueOf()
	});

});

//start server
http.listen(PORT, function (){
	console.log('Server started!');
})